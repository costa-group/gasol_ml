// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "./VRFv2Consumer.sol";
import "./INounsVisionBatchTransfer.sol";

// crafted by 0xDigitalOil with ❤️ for Nouns DAO ⌐◨-◨
contract NounsVisionVRFDistributor is VRFv2Consumer {
    
    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      EVENTS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    /// dev Event log for when Nouns Vision Glasses are won
    /// param roundId the round number
    /// param randomResult random number generated by Chainlink VRF
    /// param winners list of winning wallets (can include repeat wins)
    event Winners(
        uint256 roundId,
        uint256 randomResult,
        address[] winners
    );

    /// dev Event log for when a Nouns holder claims GLASSES
    /// param holder address of GLASSES claimer
    /// param glassesClaimed number of GLASSES claimed
    event GlassesClaimed(
        address holder,
        uint256 glassesClaimed
    );


    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      CONSTANTS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    ERC721Like public constant NOUNS_VISION =
        ERC721Like(0xd8e6b954f7d3F42570D3B0adB516f2868729eC4D);

    ERC721Like public constant NOUNS_TOKEN =
        ERC721Like(0x9C8fF314C9Bc7F6e59A9d9225Fb22946427eDC03);       

    INounsVisionBatchTransfer public constant NOUNS_VISION_BATCH_TRANSFER =
        INounsVisionBatchTransfer(0x6ff4FF4Fe59D7EC571f36e36961B032027e68ceE);

    uint256 public constant CLAIM_WINDOW = 216_000; // 30 days in blocks


    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      STORAGE VARIABLES
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    struct ClaimRound {
      uint256 id;
      uint256 startBlock; 
      uint256 endBlock; // last block to claim
      mapping (address => uint256) winners; /* winnerAddress --> numberGlasses */
      uint256 numberWon;
      uint256 numberClaimed;
    }

    ClaimRound[] public claimRounds;
    uint256 public currentRound;

    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      ERRORS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    error AvailGlassesZero();   
    error ClaimPeriodNotFinished(); 
    error NoClaimRoundsOpen();
    error NoClaimsForYou();

    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      CONSTRUCTOR
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    constructor(uint64 subscriptionId) VRFv2Consumer(subscriptionId) {}    

    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      INTERNAL FUNCTIONS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    /// notice Receives randomness; determines which wallets and quantities will have claimable GLASSES. The more tokens are in the wallet, the more likely it is that it will get each individual GLASSES awarded.
    /// param _requestId Id of the VRF request
    /// param _randomWords array of random numbers returned from VRF
    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {

        super.fulfillRandomWords(_requestId, _randomWords);

        if ((claimRounds.length > 0) && (block.number <= claimRounds[currentRound].endBlock)) {
          revert ClaimPeriodNotFinished();
        }

        uint256 availGlasses = remainingAllowance();

        if (availGlasses == 0) {
          revert AvailGlassesZero(); 
        }

        // Take first random word as source of randomness
        uint256 salt = _randomWords[0];

        uint256 nounsSupply = NOUNS_TOKEN.totalSupply();
        address[] memory winners = new address[](availGlasses);

        if (claimRounds.length > 0) {
          currentRound++;
        }
        claimRounds.push();
        ClaimRound storage round = claimRounds[currentRound];
        round.id = currentRound;
        round.startBlock = block.number;
        round.endBlock = block.number + CLAIM_WINDOW;
        round.numberWon = availGlasses;
        
        uint256 winnerId;
        address winner;
        for (uint256 i = 0; i < availGlasses; i++) {
            winnerId = uint256(keccak256(abi.encode(salt, i))) % nounsSupply;
            winner = NOUNS_TOKEN.ownerOf(winnerId);
            winners[i] = winner;
            round.winners[winner]++;
        }

        emit Winners(currentRound, salt, winners);

    }

    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      PUBLIC & EXTERNAL VIEW FUNCTIONS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    /// notice Get number of claimed GLASSES per round
    /// param round round number
    function numberClaimedGlasses(uint256 round) external view returns (uint256) {
      return (claimRounds.length > 0) ? claimRounds[round].numberClaimed : 0;
    }

    /// notice Get remaining GLASSES allowance for this contract
    function remainingAllowance() public view returns (uint256) {    
      return NOUNS_VISION_BATCH_TRANSFER.allowanceFor(address(this));
    }

    /// notice Get remaining claimable number of GLASSES this round. First check if this contract's allowance was taken away and in this case, return 0.
    function remainingClaimableCurrentRound() external view returns (uint256) { 
      if (remainingAllowance() == 0) {
        return 0;
      }   
      else if ((claimRounds.length > 0) && block.number <= claimRounds[currentRound].endBlock) {
        return claimRounds[currentRound].numberWon - claimRounds[currentRound].numberClaimed;
      }
      else {
        return 0;
      }
    }

    /// notice Expired GLASSES that were not claimed in the last expired round. 
    function expiredGlassesLastRound() public view returns (uint256) {     
      if ((claimRounds.length > 0) && block.number > claimRounds[currentRound].endBlock) {
        return claimRounds[currentRound].numberWon - claimRounds[currentRound].numberClaimed;
      }
      else if ((claimRounds.length > 1) && block.number <= claimRounds[currentRound].endBlock) { // Current round still alive but previous round exists
        return claimRounds[currentRound-1].numberWon - claimRounds[currentRound-1].numberClaimed;
      }
      else {
        return 0;
      }
    }   

    /// notice Returns number of GLASSES that should be allocated for new round taking into account current allowance and number of GLASSES desired to distributed in new round. If there is a round currently open, will return 0.
    /// param numberToDistribute the number of GLASSES looking to distribute
    function additionalAllowanceRequiredFor(uint256 numberToDistribute) external view returns (uint256) {        
      if ((claimRounds.length == 0) || (block.number > claimRounds[currentRound].endBlock)) {
        return (numberToDistribute >= remainingAllowance()) ? (numberToDistribute - remainingAllowance()) : 0;
      }
      else {
        return 0;
      }
    }

    /// notice Returns number of GLASSES that are claimable by an address
    /// param receiver address that would claim GLASSES
    function claimableGlasses(address receiver) external view returns (uint256) {    
      // First check if there is a current claim round open
      if ((claimRounds.length == 0) || (block.number > claimRounds[currentRound].endBlock)) {
        return 0;
      }

      // Check if sender has claims 
      return claimRounds[currentRound].winners[receiver];
    }      

    /// notice Returns remaining number of blocks until current claim period expires
    function blocksUntilClaimExpires() external view returns (uint256) 
    {        
      if ((claimRounds.length == 0) || (block.number > claimRounds[currentRound].endBlock)) {
        return 0;
      }

      return claimRounds[currentRound].endBlock + 1 - block.number; // adding one because expiry will be the block after endBlock
    }

    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      EXTERNAL FUNCTIONS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    /// notice Claim GLASSES available to this wallet in this Claim Round
    function claimGlasses() external {

      // Check if there is a current claim round open
      if ((claimRounds.length == 0) || (block.number > claimRounds[currentRound].endBlock)) {
        revert NoClaimRoundsOpen();
      }

      // Check if sender has claims and send them
      uint256 numberClaims = claimRounds[currentRound].winners[msg.sender];
      if (numberClaims > 0) {
        claimRounds[currentRound].numberClaimed += numberClaims;
      }
      else {
        revert NoClaimsForYou();
      }

      claimRounds[currentRound].winners[msg.sender] = 0;
      uint256 startId = NOUNS_VISION_BATCH_TRANSFER.getStartId();
      address[] memory twins = new address[](numberClaims);
      for (uint256 i; i < numberClaims; i++) {
        twins[i] = msg.sender;
      }
      NOUNS_VISION_BATCH_TRANSFER.sendManyGlasses(startId, twins);      
      emit GlassesClaimed(msg.sender, numberClaims);

    }
   
}