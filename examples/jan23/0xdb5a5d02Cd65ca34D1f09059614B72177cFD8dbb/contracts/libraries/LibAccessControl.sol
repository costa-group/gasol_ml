// SPDX-License-Identifier: MIT

//////////////////////////////////////////////solarprotocol.io//////////////////////////////////////////
//_____/\\\\\\\\\\\_________/\\\\\_______/\\\_________________/\\\\\\\\\_______/\\\\\\\\\_____        //
// ___/\\\/////////\\\_____/\\\///\\\____\/\\\_______________/\\\\\\\\\\\\\___/\\\///////\\\___       //
//  __\//\\\______\///____/\\\/__\///\\\__\/\\\______________/\\\/////////\\\_\/\\\_____\/\\\___      //
//   ___\////\\\__________/\\\______\//\\\_\/\\\_____________\/\\\_______\/\\\_\/\\\\\\\\\\\/____     //
//    ______\////\\\______\/\\\_______\/\\\_\/\\\_____________\/\\\\\\\\\\\\\\\_\/\\\//////\\\____    //
//     _________\////\\\___\//\\\______/\\\__\/\\\_____________\/\\\/////////\\\_\/\\\____\//\\\___   //
//      __/\\\______\//\\\___\///\\\__/\\\____\/\\\_____________\/\\\_______\/\\\_\/\\\_____\//\\\__  //
//       _\///\\\\\\\\\\\/______\///\\\\\/_____\/\\\\\\\\\\\\\\\_\/\\\_______\/\\\_\/\\\______\//\\\_ //
//        ___\///////////__________\/////_______\///////////////__\///________\///__\///________\///__//
////////////////////////////////////////////////////////////////////////////////////////////////////////

pragma solidity ^0.8.9;

import {LibRoles} from "./LibRoles.sol";
import {LibMeta} from "../shared/libraries/LibMeta.sol";
import {Strings} from "openzeppelin/contracts/utils/Strings.sol";
import {EnumerableSet} from "openzeppelin/contracts/utils/structs/EnumerableSet.sol";

/**
 * dev Library version of the OpenZeppelin AccessControlEnumerable contract with Diamond storage.
 * See: https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControl
 * See: https://docs.openzeppelin.com/contracts/4.x/api/access#AccessControlEnumerable
 * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol
 * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControlEnumerable.sol
 */
library LibAccessControl {
  using EnumerableSet for EnumerableSet.AddressSet;

  struct RoleData {
    mapping(address => bool) members;
    bytes32 adminRole;
  }

  struct Storage {
    mapping(bytes32 => RoleData) roles;
    mapping(bytes32 => EnumerableSet.AddressSet) roleMembers;
  }

  bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

  bytes32 private constant STORAGE_SLOT =
    keccak256("tokenmember.contracts.access.LibAccessControl");

  /**
   * dev Returns the storage.
   */
  function _storage() private pure returns (Storage storage s) {
    bytes32 slot = STORAGE_SLOT;
    // solhint-disable-next-line no-inline-assembly
    assembly {
      s.slot := slot
    }
  }

  /**
   * dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
   *
   * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
   * {RoleAdminChanged} not being emitted signaling this.
   *
   * _Available since v3.1._
   */
  event RoleAdminChanged(
    bytes32 indexed role,
    bytes32 indexed previousAdminRole,
    bytes32 indexed newAdminRole
  );

  /**
   * dev Emitted when `account` is granted `role`.
   *
   * `sender` is the account that originated the contract call.
   */
  event RoleGranted(
    bytes32 indexed role,
    address indexed account,
    address indexed sender
  );

  /**
   * dev Emitted when `account` is revoked `role`.
   *
   * `sender` is the account that originated the contract call:
   *   - if using `revokeRole`, it is the admin role bearer
   *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
   */
  event RoleRevoked(
    bytes32 indexed role,
    address indexed account,
    address indexed sender
  );

  /**
   * dev Returns `true` if `account` has been granted `role`.
   */
  function hasRole(bytes32 role, address account) internal view returns (bool) {
    return
      _storage().roles[role].members[account] ||
      _storage().roles[getRoleAdmin(role)].members[account];
  }

  /**
   * dev Revert with a standard message if `LibMeta.msgSender()` is missing `role`.
   * notice This function is identical to {checkRole} but is following the naming convention.
   */
  function enforceRole(bytes32 role) internal view {
    checkRole(role, LibMeta.msgSender());
  }

  /**
   * dev Revert with a standard message if `LibMeta.msgSender()` is missing `role`.
   * Overriding this function changes the behavior of the {onlyRole} modifier.
   *
   * Format of the revert message is described in {checkRole}.
   *
   * _Available since v4.6._
   */
  function checkRole(bytes32 role) internal view {
    checkRole(role, LibMeta.msgSender());
  }

  /**
   * dev Revert with a standard message if `account` is missing `role`.
   *
   * The format of the revert reason is given by the following regular expression:
   *
   *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/
   */
  function checkRole(bytes32 role, address account) internal view {
    if (!hasRole(role, account)) {
      revert(
        string(
          abi.encodePacked(
            "AccessControl: account ",
            Strings.toHexString(uint160(account), 20),
            " is missing role ",
            Strings.toHexString(uint256(role), 32)
          )
        )
      );
    }
  }

  /**
   * dev Returns the admin role that controls `role`. See {grantRole} and
   * {revokeRole}.
   *
   * To change a role's admin, use {_setRoleAdmin}.
   */
  function getRoleAdmin(bytes32 role) internal view returns (bytes32) {
    return _storage().roles[role].adminRole;
  }

  /**
   * dev Sets `adminRole` as ``role``'s admin role.
   *
   * Emits a {RoleAdminChanged} event.
   */
  function setRoleAdmin(bytes32 role, bytes32 adminRole) internal {
    bytes32 previousAdminRole = getRoleAdmin(role);
    _storage().roles[role].adminRole = adminRole;
    emit RoleAdminChanged(role, previousAdminRole, adminRole);
  }

  /**
   * dev Grants `role` to `account`.
   *
   * Internal function without access restriction.
   */
  function grantRole(bytes32 role, address account) internal {
    if (!hasRole(role, account)) {
      _storage().roles[role].members[account] = true;
      _storage().roleMembers[role].add(account);
      emit RoleGranted(role, account, LibMeta.msgSender());
    }
  }

  /**
   * dev Revokes `role` from `account`.
   *
   * Internal function without access restriction.
   */
  function revokeRole(bytes32 role, address account) internal {
    if (hasRole(role, account)) {
      _storage().roles[role].members[account] = false;
      _storage().roleMembers[role].remove(account);
      emit RoleRevoked(role, account, LibMeta.msgSender());
    }
  }

  /**
   * dev Returns one of the accounts that have `role`. `index` must be a
   * value between 0 and {getRoleMemberCount}, non-inclusive.
   *
   * Role bearers are not sorted in any particular way, and their ordering may
   * change at any point.
   *
   * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure
   * you perform all queries on the same block. See the following
   * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]
   * for more information.
   */
  function getRoleMember(bytes32 role, uint256 index)
    internal
    view
    returns (address)
  {
    return _storage().roleMembers[role].at(index);
  }

  /**
   * dev Returns the number of accounts that have `role`. Can be used
   * together with {getRoleMember} to enumerate all bearers of a role.
   */
  function getRoleMemberCount(bytes32 role) internal view returns (uint256) {
    return _storage().roleMembers[role].length();
  }
}
