// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

import "./VRFv2Consumer.sol";
import "./INounsVisionBatchTransfer.sol";

// crafted by 0xDigitalOil for Nouns DAO
contract NounsVisionVRFDistributor is VRFv2Consumer {
    
    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      EVENTS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/
    /// dev Event log for when winners are selected and Nouns Vision Glasses are sent
    /// param randomResult random number generated by VRF
    /// param winners address of Glasses winners
    event Winners(
        uint256 randomResult,
        address[] winners
    );


    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      CONSTANTS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    ERC721Like public constant NOUNS_VISION =
        ERC721Like(0xd8e6b954f7d3F42570D3B0adB516f2868729eC4D);

    ERC721Like public constant NOUNS_TOKEN =
        ERC721Like(0x9C8fF314C9Bc7F6e59A9d9225Fb22946427eDC03);       

    address public constant NOUNS_DAO =
        0x0BC3807Ec262cB779b38D65b38158acC3bfedE10;

    INounsVisionBatchTransfer public constant NOUNS_VISION_BATCH_TRANSFER =
        INounsVisionBatchTransfer(0x6ff4FF4Fe59D7EC571f36e36961B032027e68ceE);

    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      CONSTRUCTOR
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/

    constructor(uint64 subscriptionId) VRFv2Consumer(subscriptionId) {}    

    /**
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
      INTERNAL FUNCTIONS
    ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
    **/
    /// notice Received randomness, determines which wallets to send Nouns Vision Glasses to based on how many Nouns are in each wallet
    /// param _requestId Id of the VRF request
    /// param _randomWords array of random numbers returned from VRF
    function fulfillRandomWords(
        uint256 _requestId,
        uint256[] memory _randomWords
    ) internal override {

        super.fulfillRandomWords(_requestId, _randomWords);

        // Take first random word as source of randomness
        uint256 salt = _randomWords[0];

        // Determine which glasses are available to be distributed
        (uint256 startId, uint256 availGlasses) = NOUNS_VISION_BATCH_TRANSFER.getStartIdAndBatchAmount(address(this));

        uint256 nounsSupply = NOUNS_TOKEN.totalSupply();
        address[] memory winners = new address[](availGlasses);

        uint256 winnerId;
        address winner;
        for (uint256 i = 0; i < availGlasses; i++) {
            winnerId = uint256(keccak256(abi.encode(salt, i))) % nounsSupply;
            winner = NOUNS_TOKEN.ownerOf(winnerId);
            winners[i] = winner;
            NOUNS_VISION_BATCH_TRANSFER.sendGlasses(startId + i, winner);
        }
        emit Winners(salt, winners);

    }
}